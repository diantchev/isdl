/********************************************************************************/
/* C++ logging facility simillar to java. Uses logger name to controll logging  */
/* of individual components. 							*/
/********************************************************************************/
#include <iostream>
#include <string>
#include <vector>
#include <ringqueue>


namespace isdl {

constexpr size_t LOG_QUEUE_SIZE = 1024;
constexpr size_t LOG_BUFFER_SIZE = 1024;


enum class log_level { 
	trace=4, debug=3, info=2, warning=1, error=0 
};




/**
 * Captures logging information
 */
struct log_event {
	int _log_id;
	const char *_file_name;
	int _src_line_number;
	long _timestamp;
	const char *_format_string;
	char _values[LOG_BUFFER_SIZE]; // 0 separated values 
};

using log_queue = isdl::ringqueue< log_event, uint64_t, LOG_QUEUE_SIZE >;

class logger_factory {
	struct logconfig {
		const char *_logger_name;
		int _log_id;
		log_level _log_level;
	};
	std::vector < logconfig> _loggers;
	std::unordered_map < std::string, int> _name_map;
public:
	logger_factory (const logger_factory& ) = delete;
	logger_factory& operator= ( const logger_factory& ) = delete;
	logger_factory();
	logger& get_logger ( const char *logger_name );
};


/** 
 * Implements string_buffer interface to take advantage of the available conversions to character 
 * strings
 */
class log_buffer : public std::stream_buffer < char, char_traits < char >  > {
	char *_pbase;	/// Base for the put pointer
	char *_pptr; 	/// Current position in the buffer to insert a character
	char *_epptr;   /// End of the insert buffer


	log_queue& _queue;
public: 
	log_buffer ( log_queue& queue ) : _queue { queue } {};
	
	/**
   	 * Implementation of the virtual functions
 	 *
	virtual char* pbase() const;
	virtual char* pptr() const; 
	virtual char* eptr() const;
	
	/**
	 * @breif Starts a log entry
	 * @param log_id is the identifier for the logger associated with
	 * 	the entry
	 * @param format_string log text format values placeholders 
	 * 		are identified as {}
	 * @param timestamp is the timestamp for the log entry
	 * @param file_name is the source file name
	 * @param src_line is the source line for the entry  
	void log_entry ( int log_id, const char *format_string, long timestamp,
		const char *file_name, int src_line );
		

}; 


/**
 * Extends the basic_ostream to provide custom stream buf
 * buffer
 */
class formatter : public basic_ostream < char, char_traits< char > > {
	logger_buffer& _buffer;
public:
	formatter (logger_buffer& buffer ) : basic_ostream < char, char_traits < char > >  ( &buffer ), _buffer ( buffer )
		 {} 
	/**
	 * @breif Starts a log entry
	 * @param log_id is the identifier for the logger associated with
	 * 	the entry
	 * @param format_string log text format values placeholders 
	 * 		are identified as {}
	 * @param timestamp is the timestamp for the log entry
	 * @param file_name is the source file name
	 * @param src_line is the source line for the entry  
	inline void log_entry ( int log_id, const char *format_string, long timestamp,
		const char *file_name, int src_line ) {
		_buffer.log_entry ( log_id, format_string, timestamp, file_name, src_line );
	}

}


/**
 * Logger class constructed by the logger factory which provides the reference to 
 * the logging queue
 */
class logger {
	
	constexpr char PARAMETER_START = '{';
	constexpr char PARAMETER_END  = '}';
	constexpr char FORMAT_END = '\0';

	friend class logger_factory;
	/**
	 * Assigned id for the logger
	 */
	const int _log_id;
	const log_level _log_level;
	formatter& _formatter;


	logger ( int log_id, log_level log_level, formatter& formatter ) : 
		_log_id { log_id }, 
		_log_level { log_level }, _formatter ( formatter )  {}

	/**
  	 * @brief constant expression to get the end of parameter
	 */
	constexpr int _end_parameter ( const char *fmt, const int pos ) {
		// Position with negative sign signifies end of format 
		// string 
		if ( fmt[pos] == FORMAT_END ) return -pos;
		return fmt[pos] != PARAMETER_END ? _end_parameter ( fmt, pos + 1):
				pos+1;
	} 

	/**
 	 * Find the position of the next parameter in the format string
	 */
	constexpr int _start_parameter ( const char *fmt, const int pos, 
		const int escape_count ) {
		switch ( fmt[pos] ) {
			case PARAMETER_START:
				return _start_parameter ( fmt, pos + 1, escape_count + 1);
			case FORMAT_END:
				return -pos;
			default:
				//if the first character that is 
				// not a start of parameter return the position
				// of the previous start parameter
				if ( escape_count % 2 == 1 ) {
					return pos - 1;
				} else {
					return _start_parameter ( fmt, pos+1, 0 );
				}
			
		}
	}

	constexpr template < typename Value > int _log ( const char *fmt, 
		int fmt_pos, Value value ) {
		int new_pos = _start_parameter ( fmt , fmt_pos, 0 );
		/// If position is less than 0 it has encountered
		/// the end of the formating  string
		if ( new_pos > 0 ) {
			_formatter.insert ( fmt, fmt_pos, new_pos );
			_formatter << value;
			return _end_parameter ( fmt, new_pos );
		} else {
			/// The end of the format is reached 
			/// no place holder for a parameter insert the string
			/// and return
			_formatter.insert ( fmt, fmt_pos, -new_pos );
			return new_pos;

		}
	
	}

	constexpr template < typename Value, typename... Args > 
		int _log ( const char *fmt, int fmt_pos, 
			Value value, Args... args ) {
		
		int next_pos = _log ( fmt, fmt_pos, value );
		if ( next_pos > 0 ) {
			_log ( fmt, next_pos ,  args  );
		} else {
			return next_pos;
		}
	}


public:

	template < typename... T > void log ( log_level level, const char *src_file_name,
			int src_line_num, const char *msg, T... args ) {
		if ( _log_level >= lelvel ) {

			_formatter.log_entry (_log_id, msg, timestamp, src_file_name, src_line_num );
			_log ( msg, 0, args );
			
		}
	}





};




}
